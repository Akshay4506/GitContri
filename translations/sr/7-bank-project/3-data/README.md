<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "f587e913e3f7c0b1c549a05dd74ee8e5",
  "translation_date": "2025-08-28T10:03:59+00:00",
  "source_file": "7-bank-project/3-data/README.md",
  "language_code": "sr"
}
-->
# Изградња банкарске апликације, део 3: Методе за преузимање и коришћење података

## Квиз пре предавања

[Квиз пре предавања](https://ff-quizzes.netlify.app/web/quiz/45)

### Увод

У срцу сваке веб апликације налазе се *подаци*. Подаци могу имати различите облике, али њихова главна сврха је увек приказивање информација кориснику. Са све интерактивнијим и сложенијим веб апликацијама, начин на који корисник приступа и интерагује са информацијама постао је кључни део веб развоја.

У овој лекцији ћемо видети како да асинхроно преузмемо податке са сервера и користимо их за приказивање информација на веб страници без поновног учитавања HTML-а.

### Предуслови

Потребно је да сте изградили [формулар за пријаву и регистрацију](../2-forms/README.md) као део веб апликације за ову лекцију. Такође, потребно је да инсталирате [Node.js](https://nodejs.org) и [покренете серверски API](../api/README.md) локално како бисте добили податке о налогу.

Можете тестирати да ли сервер ради исправно извршавањем ове команде у терминалу:

```sh
curl http://localhost:5000/api
# -> should return "Bank API v1.0.0" as a result
```

---

## AJAX и преузимање података

Традиционалне веб странице ажурирају приказани садржај када корисник изабере линк или пошаље податке путем формулара, поновним учитавањем целе HTML странице. Сваки пут када је потребно учитати нове податке, веб сервер враћа потпуно нову HTML страницу коју прегледач мора обрадити, прекидајући тренутну акцију корисника и ограничавајући интеракције током учитавања. Овај начин рада се назива *вишестранична апликација* или *MPA*.

![Процес ажурирања у вишестраничној апликацији](../../../../translated_images/mpa.7f7375a1a2d4aa779d3f928a2aaaf9ad76bcdeb05cfce2dc27ab126024050f51.sr.png)

Када су веб апликације постале сложеније и интерактивније, појавила се нова техника звана [AJAX (асинхрони JavaScript и XML)](https://en.wikipedia.org/wiki/Ajax_(programming)). Ова техника омогућава веб апликацијама да шаљу и преузимају податке са сервера асинхроно користећи JavaScript, без потребе за поновним учитавањем HTML странице, што резултира бржим ажурирањима и глаткијим интеракцијама корисника. Када се нови подаци добију са сервера, тренутна HTML страница може се ажурирати JavaScript-ом користећи [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model) API. Временом, овај приступ је еволуирао у оно што се данас назива [*једностранична апликација* или *SPA*](https://en.wikipedia.org/wiki/Single-page_application).

![Процес ажурирања у једнострачној апликацији](../../../../translated_images/spa.268ec73b41f992c2a21ef9294235c6ae597b3c37e2c03f0494c2d8857325cc57.sr.png)

Када је AJAX први пут уведен, једини API доступан за асинхроно преузимање података био је [`XMLHttpRequest`](https://developer.mozilla.org/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest). Међутим, модерни прегледачи сада имплементирају згоднији и моћнији [`Fetch` API](https://developer.mozilla.org/docs/Web/API/Fetch_API), који користи промисе и боље је прилагођен за манипулацију JSON подацима.

> Иако сви модерни прегледачи подржавају `Fetch API`, ако желите да ваша веб апликација ради на старијим прегледачима, увек је добра идеја да прво проверите [табелу компатибилности на caniuse.com](https://caniuse.com/fetch).

### Задатак

У [претходној лекцији](../2-forms/README.md) имплементирали смо формулар за регистрацију како бисмо креирали налог. Сада ћемо додати код за пријаву користећи постојећи налог и преузимање његових података. Отворите датотеку `app.js` и додајте нову функцију `login`:

```js
async function login() {
  const loginForm = document.getElementById('loginForm')
  const user = loginForm.user.value;
}
```

Овде почињемо тако што преузимамо елемент формулара помоћу `getElementById()`, а затим добијамо корисничко име из уноса помоћу `loginForm.user.value`. Свака контрола формулара може се приступити преко њеног имена (постављеног у HTML-у помоћу атрибута `name`) као својству формулара.

Слично ономе што смо урадили за регистрацију, креираћемо још једну функцију за извршавање захтева серверу, али овог пута за преузимање података о налогу:

```js
async function getAccount(user) {
  try {
    const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user));
    return await response.json();
  } catch (error) {
    return { error: error.message || 'Unknown error' };
  }
}
```

Користимо `fetch` API за асинхроно преузимање података са сервера, али овог пута нам нису потребни додатни параметри осим URL-а који позивамо, јер само упитујемо податке. Подразумевано, `fetch` креира [`GET`](https://developer.mozilla.org/docs/Web/HTTP/Methods/GET) HTTP захтев, што је управо оно што нам овде треба.

✅ `encodeURIComponent()` је функција која ескепује специјалне карактере за URL. Које проблеме бисмо могли имати ако не позовемо ову функцију и директно користимо вредност `user` у URL-у?

Сада ажурирамо нашу функцију `login` да користи `getAccount`:

```js
async function login() {
  const loginForm = document.getElementById('loginForm')
  const user = loginForm.user.value;
  const data = await getAccount(user);

  if (data.error) {
    return console.log('loginError', data.error);
  }

  account = data;
  navigate('/dashboard');
}
```

Прво, пошто је `getAccount` асинхрона функција, морамо је упарити са кључном речју `await` како бисмо сачекали резултат сервера. Као и код сваког захтева серверу, морамо се бавити и случајевима грешке. За сада ћемо само додати поруку у лог за приказивање грешке и вратити се на то касније.

Затим морамо сачувати податке негде како бисмо их касније користили за приказивање информација на контролној табли. Пошто променљива `account` још увек не постоји, креираћемо глобалну променљиву за њу на врху наше датотеке:

```js
let account = null;
```

Након што се кориснички подаци сачувају у променљивој, можемо прећи са странице *login* на *dashboard* користећи функцију `navigate()` коју већ имамо.

На крају, потребно је да позовемо нашу функцију `login` када се формулар за пријаву пошаље, модификујући HTML:

```html
<form id="loginForm" action="javascript:login()">
```

Тестирајте да ли све ради исправно тако што ћете регистровати нови налог и покушати да се пријавите користећи исти налог.

Пре него што пређемо на следећи део, можемо такође завршити функцију `register` додавањем овога на крај функције:

```js
account = result;
navigate('/dashboard');
```

✅ Да ли сте знали да подразумевано можете позивати серверске API-је само са *истог домена и порта* као и веб страница коју гледате? Ово је безбедносни механизам који спроводе прегледачи. Али чекајте, наша веб апликација ради на `localhost:3000`, док серверски API ради на `localhost:5000`, зашто онда ради? Коришћењем технике зване [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/docs/Web/HTTP/CORS), могуће је извршити HTTP захтеве преко различитих домена ако сервер дода посебне хедере у одговор, дозвољавајући изузетке за одређене домене.

> Сазнајте више о API-јима кроз ову [лекцију](https://docs.microsoft.com/learn/modules/use-apis-discover-museum-art/?WT.mc_id=academic-77807-sagibbon)

## Ажурирање HTML-а за приказивање података

Сада када имамо корисничке податке, морамо ажурирати постојећи HTML како бисмо их приказали. Већ знамо како да преузмемо елемент из DOM-а, на пример помоћу `document.getElementById()`. Након што имате основни елемент, ево неких API-ја које можете користити за његову модификацију или додавање поделемената:

- Коришћењем својства [`textContent`](https://developer.mozilla.org/docs/Web/API/Node/textContent) можете променити текст елемента. Имајте на уму да промена ове вредности уклања сву децу елемента (ако их има) и замењује их датим текстом. Као таква, ово је такође ефикасан метод за уклањање свих деце датог елемента додељивањем празног стринга `''`.

- Коришћењем [`document.createElement()`](https://developer.mozilla.org/docs/Web/API/Document/createElement) заједно са методом [`append()`](https://developer.mozilla.org/docs/Web/API/ParentNode/append) можете креирати и додати један или више нових поделемената.

✅ Коришћењем својства [`innerHTML`](https://developer.mozilla.org/docs/Web/API/Element/innerHTML) елемента могуће је променити његов HTML садржај, али ово би требало избегавати јер је подложно нападима [cross-site scripting (XSS)](https://developer.mozilla.org/docs/Glossary/Cross-site_scripting).

### Задатак

Пре него што пређемо на екран контролне табле, постоји још једна ствар коју треба да урадимо на страници *login*. Тренутно, ако покушате да се пријавите са корисничким именом које не постоји, порука се приказује у конзоли, али за обичног корисника ништа се не мења и не знате шта се дешава.

Додајмо елемент за приказивање поруке о грешци у формулару за пријаву. Добро место би било непосредно пре дугмета за пријаву `<button>`:

```html
...
<div id="loginError"></div>
<button>Login</button>
...
```

Овај `<div>` елемент је празан, што значи да се ништа неће приказати на екрану док не додамо неки садржај. Такође му дајемо `id` како бисмо га лакше пронашли помоћу JavaScript-а.

Вратите се у датотеку `app.js` и креирајте нову помоћну функцију `updateElement`:

```js
function updateElement(id, text) {
  const element = document.getElementById(id);
  element.textContent = text;
}
```

Ова функција је прилично једноставна: с обзиром на *id* елемента и *текст*, ажурираће текстуални садржај DOM елемента са одговарајућим `id`. Користимо ову методу уместо претходне поруке о грешци у функцији `login`:

```js
if (data.error) {
  return updateElement('loginError', data.error);
}
```

Сада, ако покушате да се пријавите са неважећим налогом, требало би да видите нешто овако:

![Снимак екрана који приказује поруку о грешци током пријаве](../../../../translated_images/login-error.416fe019b36a63276764c2349df5d99e04ebda54fefe60c715ee87a28d5d4ad0.sr.png)

Сада имамо текст грешке који се визуелно приказује, али ако га испробате са читачем екрана, приметићете да се ништа не најављује. Да би текст који се динамички додаје на страницу био најављен од стране читача екрана, потребно је да користи нешто што се зове [Live Region](https://developer.mozilla.org/docs/Web/Accessibility/ARIA/ARIA_Live_Regions). Овде ћемо користити специфичан тип live региона зван *alert*:

```html
<div id="loginError" role="alert"></div>
```

Примените исто понашање за грешке у функцији `register` (не заборавите да ажурирате HTML).

## Приказивање информација на контролној табли

Користећи исте технике које смо управо видели, такође ћемо се побринути за приказивање информација о налогу на страници контролне табле.

Овако изгледа објекат налога добијен са сервера:

```json
{
  "user": "test",
  "currency": "$",
  "description": "Test account",
  "balance": 75,
  "transactions": [
    { "id": "1", "date": "2020-10-01", "object": "Pocket money", "amount": 50 },
    { "id": "2", "date": "2020-10-03", "object": "Book", "amount": -10 },
    { "id": "3", "date": "2020-10-04", "object": "Sandwich", "amount": -5 }
  ],
}
```

> Напомена: да бисте себи олакшали живот, можете користити унапред постојећи налог `test` који је већ попуњен подацима.

### Задатак

Почнимо заменом секције "Balance" у HTML-у како бисмо додали елементе за приказивање:

```html
<section>
  Balance: <span id="balance"></span><span id="currency"></span>
</section>
```

Такође ћемо додати нову секцију одмах испод за приказивање описа налога:

```html
<h2 id="description"></h2>
```

✅ Пошто опис налога функционише као наслов за садржај испод њега, означен је семантички као наслов. Сазнајте више о томе колико је [структура наслова](https://www.nomensa.com/blog/2017/how-structure-headings-web-accessibility) важна за приступачност и критички погледајте страницу како бисте утврдили шта још може бити наслов.

Затим ћемо креирати нову функцију у `app.js` за попуњавање ових елемената:

```js
function updateDashboard() {
  if (!account) {
    return navigate('/login');
  }

  updateElement('description', account.description);
  updateElement('balance', account.balance.toFixed(2));
  updateElement('currency', account.currency);
}
```

Прво, проверавамо да ли имамо податке о налогу који су нам потребни пре него што наставимо. Затим користимо функцију `updateElement()` коју смо раније креирали за ажурирање HTML-а.

> Да би приказивање стања било лепше, користимо методу [`toFixed(2)`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) како бисмо приказали вредност са 2 децимале.

Сада морамо позвати нашу функцију `updateDashboard()` сваки пут када се прикаже страница контролне табле. Ако сте већ завршили [задатак из лекције 1](../1-template-route/assignment.md), ово би требало да буде једноставно, у супротном можете користити следећу имплементацију.

Додајте овај код на крај функције `updateRoute()`:

```js
if (typeof route.init === 'function') {
  route.init();
}
```

И ажурирајте дефиницију рута са:

```js
const routes = {
  '/login': { templateId: 'login' },
  '/dashboard': { templateId: 'dashboard', init: updateDashboard }
};
```

Са овом променом, сваки пут када се прикаже страница контролне табле, позива се функција `updateDashboard()`. Након пријаве, требало би да видите стање налога, валуту и опис.

## Динамичко креирање редова табеле помоћу HTML шаблона

У [првој лекцији](../1-template-route/README.md) користили смо HTML шаблоне заједно са методом [`appendChild()`](https://developer.mozilla.org/docs/Web/API/Node/appendChild) за имплементацију навигације у нашој апликацији. Шаблони могу бити и мањи и користити се за динамичко попуњавање понављајућих делова странице.

Користићемо сличан приступ за приказивање листе трансакција у HTML табели.

### Задатак

Додајте нови шаблон у `<body>` HTML-а:

```html
<template id="transaction">
  <tr>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</template>
```

Овај шаблон представља један ред табеле, са 3 колоне које желимо да попунимо: *датум*, *објекат* и *износ* трансакције.

Затим додајте ово својство `id` елементу `<tbody>` табеле унутар шаблона контролне табле како би га било лакше пронаћи помоћу JavaScript-а:

```html
<tbody id="transactions"></tbody>
```

Наш HTML је спреман, пређимо на JavaScript код и креирајмо нову функцију `createTransactionRow`:

```js
function createTransactionRow(transaction) {
  const template = document.getElementById('transaction');
  const transactionRow = template.content.cloneNode(true);
  const tr = transactionRow.querySelector('tr');
  tr.children[0].textContent = transaction.date;
  tr.children[1].textContent = transaction.object;
  tr.children[2].textContent = transaction.amount.toFixed(2);
  return transactionRow;
}
```

Ова функција ради управо оно што њено име имплицира: користећи шаблон који смо раније креирали, креира нови ред табеле и попуњава његов садржај користећи податке о трансакцији. Користићемо ово у нашој функцији `updateDashboard()` за попуњавање табеле:

```js
const transactionsRows = document.createDocumentFragment();
for (const transaction of account.transactions) {
  const transactionRow = createTransactionRow(transaction);
  transactionsRows.appendChild(transactionRow);
}
updateElement('transactions', transactionsRows);
```

Овде користимо методу [`document.createDocumentFragment()`](https://developer.mozilla.org/docs/Web/API/Document/createDocumentFragment) која креира нови DOM фрагмент на коме можемо радити, пре него што га коначно додамо у нашу HTML табелу.

Још увек постоји једна ствар коју морамо у
Ако покушате да се пријавите користећи налог `test`, сада би требало да видите листу трансакција на контролној табли 🎉.

---

## 🚀 Изазов

Радите заједно како бисте страницу контролне табле учинили да изгледа као права апликација за банкарство. Ако сте већ стилизовали своју апликацију, покушајте да користите [media queries](https://developer.mozilla.org/docs/Web/CSS/Media_Queries) за креирање [респонзивног дизајна](https://developer.mozilla.org/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks) који добро функционише и на десктоп и на мобилним уређајима.

Ево примера стилизоване странице контролне табле:

![Снимак екрана пример резултата контролне табле након стилизовања](../../../../translated_images/screen2.123c82a831a1d14ab2061994be2fa5de9cec1ce651047217d326d4773a6348e4.sr.png)

## Квиз након предавања

[Квиз након предавања](https://ff-quizzes.netlify.app/web/quiz/46)

## Задатак

[Рефакторишите и коментаришите свој код](assignment.md)

---

**Одрицање од одговорности**:  
Овај документ је преведен коришћењем услуге за превођење помоћу вештачке интелигенције [Co-op Translator](https://github.com/Azure/co-op-translator). Иако се трудимо да обезбедимо тачност, молимо вас да имате у виду да аутоматски преводи могу садржати грешке или нетачности. Оригинални документ на његовом изворном језику треба сматрати меродавним извором. За критичне информације препоручује се професионални превод од стране људи. Не сносимо одговорност за било каква погрешна тумачења или неспоразуме који могу настати услед коришћења овог превода.